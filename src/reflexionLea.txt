## Fonctions utiles :

ImGui::ShowDemoWindow();
-> pour voir un menu d'exemple

ImGui::SeparatorText("Pouet");
-> pour faire une section

ImGui::NewLine();
-> pour créer une ligne vide

## Choix du nombre de boids
Avoir un menu avant de lancer le jeu ou on peut définir le nombre de boids souhaité.
Puis lancer le jeu ensuite.

-----------------------------------------------------------------------------------------------------------

## Chaine de Markov appliquée à la couleur du fond
En gros,

On a un "groupe" qui permet de fixer une couleur selon trois composantes qui sont rouge, vert, Blue; 
Je dis "groupe" car il faut que l'on réfléchisse à sa nature, une class, une struct ... ?


Ensuite, on crée trois groupes qui sont trois nuances de bleu (ou autre couleur en soit on s'en fout pour l'instant)

Ensuite, en termes de timing
Quelle est la durée d'un "aujourd'hui" ? La question se pose dans l'autre sens, créons un chronomètre.

Ainsi un "aujourd'hui" a une durée t.

Puis, toutes les durées t "demain" arrive.

Alors là ça devient compliqué. La couleur de "demain" est déterminée selon les probabilités d'apparition. Elles sont à fixer. Ces couleurs dépendent de la couleur d'aujourd'hui. C'est mal expliqué mais c'est assez simple à comprendre, il faut se reporter au schéma vu en cours.

Prenons trois groupes de couleurs :
A, B, C dans cet ordre

Pour simplifier ce que je raconte, on va prendre les mêmes probabilités d'apparition pour toutes les couleurs. Ainsi on a une proba de 1/3. Mais elle pourra être changée et adaptée pour chaque groupe.

----- à faire ----
Reprendre exo du cours pour le tirage de l'aléatoire
tirage entre 0 et 1 et la valeur trouvée sera utilisée par la fonction de Markov.

On a déjà une fonction random qui tire un nombre entre 0 et 1.

-----------------------------------------------------------------------------------------------------------
// Chaine de Markov

#include <iostream>
#include <random>
#include <vector>

// Imaginons trois couleurs différentes
struct Color {
    int r;
    int g;
    int b;
};

float rand01()
{
    thread_local std::default_random_engine gen{std::random_device{}()};
    thread_local auto                       distrib = std::uniform_real_distribution<float>{0.0, 1.0};
    return distrib(gen);
}

// Fonction qui génère la couleur suivante en utilisant la chaîne de Markov
Color nextColor(const Color& currentColor) {
    double stayProbability = 0.7; // Probabilité de rester dans le même état
    double transitionProbability = (1.0 - stayProbability) / 2.0; // Probabilité de transition vers un autre état
    
    // On utilise l'aléatoire pour décider de la transition
    float transition = rand01();

    if (transition < stayProbability) {
        // Rester dans le même état
        return currentColor;
    } else if (transition < stayProbability + transitionProbability) {
        // Transition vers l'état 2
        return {255, 0, 0}; // Rouge
    } else {
        // Transition vers l'état 3
        return {0, 255, 0}; // Vert
    }
}

int main() {
    Color initialColor = {0, 0, 255}; // Couleur initiale (bleu)

    Color next = nextColor(initialColor);

    return 0;
}

-----------------------------------------------------------------------------------------------------------

## Réflexion sur la loi binomiale appliquée aux nombres de poissons de chaque groupe
En paramètre fixe, on a le nombre de poissons total. Appelons-le nbFishTotal et prenons nbFishTotal = 20.

Ensuite on a nos trois catégories de poissons, les petits, les moyens et les gros.
Il peut y avoir au maximum :
- 5 gros poissons, nbBigFish
- 12 petits poissons nbLittleFish
- le reste sur les 20 sont des moyens poissons nbMediumFish

La répartition (au maximum) est donc de :
- Gros poisquailles : 5/20 soit 1/4 de nbFishTotal
- Mini poisquailles : 12/20 soit 3/5 de nbFishTotal
- Moyens poissons : nbFishTotal - (nbBigFish + nbLittleFish)

Appliquons une loi binomiale sur le nombre de gros poissons et une autre sur le nombre de petits poissons.
On a donc nos bornes :
- Entre 1 et 5 gros poissons. Faisons notre loi sur 0 - 4 et on fait +1 à la fin.

- Entre 1 et 12 gros poissons. Faisons notre loi sur 0 - 11 et on fait +1 à la fin également.

Ok ça ce sont les valeurs auxquelles on peut se rapporter.

Passons à la loi binomiale.
En terme de code ça donnerait ça :

-----------------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <random>


// La fonction rand01() est déjà implémentée dans tools.cpp
float rand01()
{
    thread_local std::default_random_engine gen{std::random_device{}()};
    thread_local auto                       distrib = std::uniform_real_distribution<float>{0.0, 1.0};
    return distrib(gen);
}

int binomialDistribution(int n, float p) {
    int x = 0;
    for (int i = 0; i < n; ++i) {
        if (rand01() < p) {
            x++;
        }
    }
    return x+1; // On s'assure d'avoir au moins 1 poisson
}

int main() {
    float p = 0.5;  // p est compris entre 0 et 1. Pour p = 0.5, la loi est équilibrée.
    int nbFishTotal = 20;
    
    int nbBigFish = binomialDistribution(4, 0.5);
    int nbLittleFish = binomialDistribution(11, 0.5);
    int nbMediumFish = nbFishTotal - (nbBigFish + nbLittleFish);
    
    return 0;
}

-----------------------------------------------------------------------------------------------------------
// La loi de Bernoulli c'est la même chose mais sur un seul essai, on n'a pas le nombre de lancers n.

int bernoulliDistribution(float p) {
    if (rand01() < p) { // Avec p = 0.5 pour une loi équitable
        return 1; // Succès
    } else {
        return 0; // Échec
    }
}
-----------------------------------------------------------------------------------------------------------
A FAIRE : Au même niveau qe src, faire un dossier "proba" et un fichier pour chaque loi.

-----------------------------------------------------------------------------------------------------------
Maintenant faisons de même avec la loi exponentielle.

#include <iostream>
#include <vector>
#include <cmath>
#include <random>

En utilisant la fonction rand01() :

float exponentialDistribution(float lambda)
{
    return -log(1 - rand01()) / lambda;
}

Le paramètre lambda correspond à la "force" de décroissance de la courbe.
Plus lambda est élevé, plus la courbe va décroitre brutalement.

-----------------------------------------------------------------------------------------------------------
Qu'en est-il de la loi gaussienne ? On peut l'utiliser pour la position d'apparition des gros poissons.

En utilisant la fonction rand01() :

#include <iostream>
#include <cmath>
#include <random>

float gaussianDistribution(float average, float standardDeviation)
{
    float u1 = rand01();
    float u2 = rand01();
    
    float z0 = sqrt(-2.0 * log(u1)) * cos(2.0 * M_PI * u2);
    return average + standardDeviation * z0;
}

float littleBoidsLocation(float squareSize)
{
    return gaussianDistribution(0.0f, squareSize / 3.0f); 
    // La moyenne est à 0 pour faire apparaitre les boids autour de (0, 0, 0)
    // L'écart-type, standardDerivation, peut être modifié selon si on veut un "petit" centre ou un "grand" centre
}

int main() {
    float squareSize = 10.0f; // À adapter puisqu'il s'agira de récupérer la valeur et non de la fixer.
    
    // Définir la position des boids dans le carré selon les axes x, y et z pour la 3D
    float x_boid = littleBoidsLocation(squareSize);
    float y_boid = littleBoidsLocation(squareSize);
    float z_boid = littleBoidsLocation(squareSize);
        
    return 0;
}

-----------------------------------------------------------------------------------------------------------
J'en suis moins sûre mais on pourrait utiliser une loi bêta pour la position d'apparition des petits poissons.

En utilisant la fonction rand01() :

#include <iostream>
#include <cmath>
#include <random>

float betaDistribution(float alpha, float beta)
{
    float u1 = rand01();
    float u2 = rand01();
    
    return pow(u1, alpha) * pow(u2, beta);
}

float littleBoidsLocation(float squareSize)
{
    float alpha = 0.5f;
    float beta = 0.5f;
    // Si j'ai bien compris, pour avoir une loi bêta en forme d'hyperbole, il faut que les paramètres alpha et beta soient proches de 0.
    
    return squareSize * betaDistribution(alpha, beta);
}

int main() {
    float squareSize = 10.0f; // Taille d'un côté du carré/cube
    
    float x_boid = littleBoidsLocation(squareSize);
    float y_boid = littleBoidsLocation(squareSize);
    float z_boid = littleBoidsLocation(squareSize);
    
    return 0;
}

-----------------------------------------------------------------------------------------------------------
Ok ça nous fait 4 lois (car Bernoulli et binomiale c'est la même chose).

Je ne sais pas si une loi uniforme c'est utile.
On peut aussi faire une loi de Poisson. Mais je ne sais pas trop dans quel cas elle pourrait servir.

-----------------------------------------------------------------------------------------------------------


