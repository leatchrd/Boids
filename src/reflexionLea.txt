## Fonctions utiles :

ImGui::ShowDemoWindow();
-> pour voir un menu d'exemple

ImGui::SeparatorText("Pouet");
-> pour faire une section

ImGui::NewLine();
-> pour créer une ligne vide

## Choix du nombre de boids
Avoir un menu avant de lancer le jeu ou on peut définir le nombre de boids souhaité.
Puis lancer le jeu ensuite.

-----------------------------------------------------------------------------------------------------------

## Chaine de Markov appliquée à la couleur du fond
En gros,

On a un "groupe" qui permet de fixer une couleur selon trois composantes qui sont rouge, vert, Blue; 
Je dis "groupe" car il faut que l'on réfléchisse à sa nature, une class, une struct ... ?


Ensuite, on crée trois groupes qui sont trois nuances de bleu (ou autre couleur en soit on s'en fout pour l'instant)

Ensuite, en termes de timing
Quelle est la durée d'un "aujourd'hui" ? La question se pose dans l'autre sens, créons un chronomètre.

Ainsi un "aujourd'hui" a une durée t.

Puis, toutes les durées t "demain" arrive.

Alors là ça devient compliqué. La couleur de "demain" est déterminée selon les probabilités d'apparition. Elles sont à fixer. Ces couleurs dépendent de la couleur d'aujourd'hui. C'est mal expliqué mais c'est assez simple à comprendre, il faut se reporter au schéma vu en cours.

Prenons trois groupes de couleurs :
A, B, C dans cet ordre

Pour simplifier ce que je raconte, on va prendre les mêmes probabilités d'apparition pour toutes les couleurs. Ainsi on a une proba de 1/3. Mais elle pourra être changée et adaptée pour chaque groupe.

----- à faire ----
Reprendre exo du cours pour le tirage de l'aléatoire
tirage entre 0 et 1 et la valeur trouvée sera utilisée par la fonction de Markov.

On a déjà une fonction random qui tire un nombre entre 0 et 1.

Faire la fonction loiMarkov

-----------------------------------------------------------------------------------------------------------

## Réflexion sur la loi binomiale appliquée aux nombres de poissons de chaque groupe
En paramètre fixe, on a le nombre de poissons total. Appelons-le nbFishTotal et prenons nbFishTotal = 20.

Ensuite on a nos trois catégories de poissons, les petits, les moyens et les gros.
Il peut y avoir au maximum :
- 5 gros poissons, nbBigFish
- 12 petits poissons nbLittleFish
- le reste sur les 20 sont des moyens poissons nbMediumFish

La répartition (au maximum) est donc de :
- Gros poisquailles : 5/20 soit 1/4 de nbFishTotal
- Mini poisquailles : 12/20 soit 3/5 de nbFishTotal
- Moyens poissons : nbFishTotal - (nbBigFish + nbLittleFish)

Appliquons une loi binomiale sur le nombre de gros poissons et une autre sur le nombre de petits poissons.
On a donc nos bornes :
- Entre 1 et 5 gros poissons. Faisons notre loi sur 0 - 4 et on fait +1 à la fin.

- Entre 1 et 12 gros poissons. Faisons notre loi sur 0 - 11 et on fait +1 à la fin également.

Ok ça ce sont les valeurs auxquelles on peut se rapporter.

Passons à la loi binomiale.
En terme de code ça donnerait ça :

-----------------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <random>


// La fonction rand01() est déjà implémentée dans tools.cpp
float rand01()
{
    thread_local std::default_random_engine gen{std::random_device{}()};
    thread_local auto                       distrib = std::uniform_real_distribution<float>{0.0, 1.0};
    return distrib(gen);
}

int binomialDistribution(int n, float p) {
    int x = 0;
    for (int i = 0; i < n; ++i) {
        if (rand01() < p) {
            x++;
        }
    }
    return x+1; // On s'assure d'avoir au moins 1 poisson
}

int main() {
    float p = 0.5;  // p est compris entre 0 et 1. Pour p = 0.5, la loi est équilibrée.
    int nbFishTotal = 20;
    
    int nbBigFish = binomialDistribution(4, 0.5);
    int nbLittleFish = binomialDistribution(11, 0.5);
    int nbMediumFish = nbFishTotal - (nbBigFish + nbLittleFish);
    
    return 0;
}

-----------------------------------------------------------------------------------------------------------
A FAIRE : Au même niveau qe src, faire un dossier "proba" et un fichier pour chaque loi.

-----------------------------------------------------------------------------------------------------------
Maintenant faisons de même avec la loi exponentielle

#include <iostream>
#include <vector>
#include <cmath>
#include <random>

En utilisant la fonction rand01() :

float exponentialDistribution(float lambda)
{
    return -log(1 - rand01()) / lambda;
}

Le paramètre lambda correspond à la "force" de décroissance de la courbe.
Plus lambda est élevé, plus la courbe va décroitre brutalement.

-----------------------------------------------------------------------------------------------------------
Qu'en est-il de la loi gaussienne ?

En utilisant la fonction rand01() :

#include <iostream>
#include <cmath>
#include <random>

float gaussianDistribution(float average, float standardDeviation)
{
    float u1 = rand01();
    float u2 = rand01();
    
    float z0 = sqrt(-2.0 * log(u1)) * cos(2.0 * M_PI * u2);
    return average + standardDeviation * z0;
}

float boidLocation(float squareSize)
{
    return gaussianDistribution(0.0f, squareSize / 3.0f); 
    // La moyenne est à 0 pour faire apparaitre les boids autour de (0, 0, 0)
    // L'écart-type, standardDerivation, peut être modifié selon si on veut un "petit" centre ou un "grand" centre
}

int main() {
    float squareSize = 10.0f; // À adapter puisqu'il s'agira de récupérer la valeur et non de la fixer.
    
    // Définir la position des boids dans le carré selon les axes x, y et z pour la 3D
    float x_boid = boidLocation(squareSize);
    float y_boid = boidLocation(squareSize);
    float z_boid = boidLocation(squareSize);
        
    return 0;
}

-----------------------------------------------------------------------------------------------------------
Qu'en est-il de la loi gaussienne ?